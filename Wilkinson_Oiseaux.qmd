## R code For Geographical coordinates cleaning and processing

```{r}
library(ggplot2)
library(dplyr)
getwd()

# Import data
options(encoding = "latin1")
raw_data <- read.csv("data/raw/synthese_observations_oiseaux.csv", sep = ";")

# Convert raw_data into processed_data

# select necessary columns
process_data <- raw_data %>% select(id_synthese, date_debut, date_fin,heure_debut, heure_fin, nom_vernaculaire, nombre_min,observateurs,determinateur,x_centroid_4326, y_centroid_4326,nom_lieu,champs_additionnels)

# write new file
write.csv(process_data, file = "C:/Users/rapha/Desktop/MASTER 2 RAINET/UE Projet entreprise/oiseaux_bagnas/data/processed/process_data.csv", row.names = FALSE)

bird_data <- read.csv("data/processed/process_data.csv", sep = ",")

bird_data$nom_lieu <- as.factor(bird_data$nom_lieu)
levels(bird_data$nom_lieu)

coord_summary <- bird_data %>%
  group_by(x_centroid_4326, y_centroid_4326) %>%                 
  summarise(
    n_sites = n_distinct(nom_lieu),                              
    site_names = paste(unique(nom_lieu), collapse = ", "),       
    coord_unique = n_sites == 1                                   
  ) %>%
  ungroup() %>%
  arrange(desc(n_sites)) 


bird_data <- bird_data %>%
  mutate(nom_lieu = ifelse(is.na(nom_lieu) | nom_lieu == "",
                           paste0("unnamedSite", row_number()), 
                           as.character(nom_lieu)))

bird_data <- bird_data %>%
  mutate(nom_lieu = as.character(nom_lieu)) %>%
  mutate(nom_lieu = ifelse(nom_lieu %in% c("Portiragnes", "RNNbagnas", "Bessan"),
                           "SudEtangBagnas",
                           nom_lieu)) %>%
  mutate(nom_lieu = as.factor(nom_lieu))

bird_data$nom_lieu <- as.factor(bird_data$nom_lieu)

levels(bird_data$nom_lieu)

coord_summary <- bird_data %>%
  group_by(x_centroid_4326, y_centroid_4326) %>%                 
  summarise(
    n_sites = n_distinct(nom_lieu),                              
    site_names = paste(unique(nom_lieu), collapse = ", "),      
    coord_unique = n_sites == 1                                  
  ) %>%
  ungroup() %>%
  arrange(desc(n_sites))

```

## R code for hydrological data processing

```{r}

### Importe les packages
library(ggplot2)
library(dplyr)
library(lubridate)
library(purrr)

HydrologicData <- read.csv("data/raw/DataHydro.csv", sep = ";")
HydrologicDataGrandBagnas <- HydrologicData %>%
  select(Station, Date.Releve, Heure, Salinite, Temperature, Niveau.Ngf, Niveau.Relatif)%>%
  mutate(Profondeur = (Niveau.Ngf+0.27),
         Date.Releve = as.Date(Date.Releve, format = "%d/%m/%Y"),
         Annee = as.integer(format(Date.Releve, "%Y")),
         Mois = format(Date.Releve, "%m"),
         Jour = yday(Date.Releve))%>%
  filter(Station == "Etangs du Grand Bagnas - TB5 centre",
         Annee > 2013)

### Calcule la profondeur et l'altitude moyenne (de l'eau) mensuelle
Hydro_moyenne <- HydrologicDataGrandBagnas %>%
  group_by(Annee, Mois) %>%
  summarise(
    ProfondeurMoyenne = mean(Profondeur, na.rm = TRUE),
    AltitudeMoyenne = mean(Niveau.Ngf, na.rm = TRUE),
    .groups = "drop"    # <--- important pour éviter des regroupements inutiles
  )

### Code une variable Assec (mois par mois) et AssecT (niveau le plus extreme de l'année) 
HydrologicDataGrandBagnas <- HydrologicDataGrandBagnas %>%
  mutate(
    Assec = case_when(
      is.na(Profondeur) ~ "total",
      Profondeur < 0.2  ~ "partiel",
      TRUE                     ~ "non"),
    Assec_score = case_when(
      Assec == "non"     ~ 1,
      Assec == "partiel" ~ 2,
      Assec == "total"   ~ 3)) %>%
  group_by(Annee) %>%
  mutate(
    AssecT = case_when(
      max(Assec_score, na.rm = TRUE) == 3 ~ "total",
      max(Assec_score, na.rm = TRUE) == 2 ~ "partiel",
      TRUE                                ~ "non")) %>%
  ungroup() %>%
  select(-Assec_score)

### Crée une variable AssecT_1 (AssecT de l'année précédente)
Assec_annuel <- HydrologicDataGrandBagnas %>%
  distinct(Annee, AssecT) %>%
  bind_rows(tibble(Annee = 2014, AssecT = "non")) %>%
  filter(Annee != 2026) %>%                             
  arrange(Annee) %>%
  mutate(AssecT_1 = lag(AssecT),
         AssecT_1 = if_else(Annee == 2014, "non", AssecT_1))%>%
  group_by(Annee) %>%
  slice(1) %>%   
  ungroup()

## Ajoute la variable AssecT_1 au tableau HydrologicDataGrandBagnas
HydrologicDataGrandBagnas <- HydrologicDataGrandBagnas %>%
  left_join(
    Assec_annuel %>% select(Annee, AssecT_1),
    by = "Annee")

## Conserve que les bonnes variables 
HydrologicDataGrandBagnas <- HydrologicDataGrandBagnas[,c(8,9,10,11,14)]

## Remplace les valeurs NA de Profondeur par 0
HydrologicDataGrandBagnas <- HydrologicDataGrandBagnas %>%
  mutate(Profondeur = if_else(is.na(Profondeur), 0, Profondeur))

## Convertit Mois en numérique  
HydrologicDataGrandBagnas$Mois <- as.numeric(as.character(HydrologicDataGrandBagnas$Mois))

## Graphique de la profondeur moyenne mensuelle par année
ggplot(HydrologicDataGrandBagnas, aes(x = Mois, y = Profondeur)) +
  geom_line() +
  geom_point() +
  facet_wrap(~ Annee, ncol = 3) +
  scale_x_continuous(breaks = 1:12) +
  theme_bw()

## INTERPOLATION LINÉAIRE DE LA PROFONDEUR JOURNALIÈRE
jours_par_annee <- function(df) {
  data.frame(Jour = 1:365)}

DataInterpolationProfondeur <- HydrologicDataGrandBagnas %>%
  group_by(Annee) %>%
  group_modify(~ {    interp <- approx(
      x = .x$Jour,
      y = .x$Profondeur,
      xout = 1:365,   
      rule = 2         )
    tibble(
      Jour = interp$x,
      Profondeur = interp$y)}) %>% ungroup()

AssecT_1_annee <- HydrologicDataGrandBagnas %>%
  select(Annee, AssecT_1) %>%
  distinct()

HydrologicDataGrandBagnas <- DataInterpolationProfondeur %>%
  left_join(AssecT_1_annee, by = "Annee")

## Enregistre le tableau final dans le fichier processed
write.csv(HydrologicDataGrandBagnas, file = "data/pro/DataHydroBagnas.csv", row.names = FALSE)

```

## R code for binomial GLM

### Importation of necessary datasets

```{r}
library(ggplot2)
library(dplyr)
library(broom)

## Importation des données
BirdDataProtocol <- read.csv("data/pro/process_protocole.csv", sep = ",")

## création de la variable Occurence (1 si au moins un individu observé, 0 sinon)
BirdDataProtocol$Occurence <- ifelse(BirdDataProtocol$nombre_min > 0, 1, 0)

```

## BLONGIOS NAIN

```{r}

## filtre les données pour le blongios nain
Blongios_nain <- BirdDataProtocol %>%
  filter(nom_vernaculaire == "Blongios nain, Butor blongios")

### Modeles emboités 

modele_julian2_annee <- glm(Occurence ~ julian + I(julian^2)+annee,
                   data = Blongios_nain, 
                   family = binomial)
modele_complet_site <- glm(Occurence~ annee + julian + I(julian^2)+ nom_lieu,
                        data = Blongios_nain, 
                   family = binomial )
modele_complet_anneesite <- glm(Occurence~ annee*nom_lieu + julian + I(julian^2),
                        data = Blongios_nain, 
                   family = binomial )
modele_complet_site <- glm(Occurence~ annee + julian + I(julian^2)+ nom_lieu,
                        data = Blongios_nain, 
                   family = binomial )
modele_complet_vent <- glm(Occurence~ annee + julian + I(julian^2)+ nom_lieu + vent_moyen,
                        data = Blongios_nain, 
                   family = binomial )
modele_complet_temp_31 <- glm(Occurence~ annee + julian + I(julian^2)+ nom_lieu + temp_moy_glissante_31j+ vent_moyen,
                        data = Blongios_nain, 
                   family = binomial )
modele_complet_temp_7j <- glm(Occurence~ annee + julian + I(julian^2)+ nom_lieu + temp_moy_glissante_7j+ vent_moyen,
                        data = Blongios_nain, 
                   family = binomial )
modele_complet_temp_1j<- glm(Occurence~ annee + julian + I(julian^2)+ nom_lieu + temperature,
                        data = Blongios_nain, 
                   family = binomial )
modele_complet_temp_1j_vent<- glm(Occurence~ annee + julian + I(julian^2)+ nom_lieu + temperature + vent_moyen,
                        data = Blongios_nain, 
                   family = binomial )
modele_complet_pluie_31j_vent<- glm(Occurence~ annee + julian + I(julian^2)+ nom_lieu + pluie_moy_glissante_31j + vent_moyen,
                        data = Blongios_nain, 
                   family = binomial )
modele_complet_pluie_7j_vent<- glm(Occurence~ annee + julian + I(julian^2)+ nom_lieu + pluie_moy_glissante_7j + vent_moyen,
                        data = Blongios_nain, 
                   family = binomial )
modele_complet_pluie_1j_vent<- glm(Occurence~ annee + julian + I(julian^2)+ nom_lieu + pluie_1h + vent_moyen,
                        data = Blongios_nain, 
                   family = binomial )


AIC(modele_complet_site, modele_complet_anneesite, modele_complet_vent , modele_complet_temp_31, modele_complet_temp_7j, 
modele_complet_temp_1j, modele_complet_temp_1j_vent, modele_complet_pluie_31j_vent, modele_complet_pluie_7j_vent, modele_complet_pluie_1j_vent)

## meilleur modèle selon AIC

modele_complet_pluie_7j_vent<- glm(Occurence~ annee + julian + I(julian^2)+ nom_lieu + pluie_moy_glissante_7j + vent_moyen,
                        data = Blongios_nain, 
                        family = binomial )

summary(modele_complet_pluie_7j_vent)


```

Le modèle GLM examinant la présence du Blongios nain en fonction du temps, de la profondeur et de l’assec de l’année précédente montre plusieurs résultats intéressants. La date julienne sur plusieurs années et son terme quadratique sont toutes deux significatifs (p ≈ 0,0015), suggérant une évolution non linéaire et négative de la probabilité de présence au cours de la période 2014–2024. La profondeur moyenne n’a pas d’effet significatif (p = 0,34), ce qui indique que la présence de l’espèce n’est pas fortement liée aux variations de profondeur dans ce dataset. En revanche, l’assec de l’année précédente influence fortement la probabilité de présence: un assec partiel réduit la probabilité (Estimate = -2,19, p = 0,03) et un assec total encore davantage (Estimate = -4,27, p = 0,002)

## TALEVE SULTANE

```{r}

## colonnes à garder
cols_keep <- c(1, 2, 3, 6, 7, 12, 14)

## modèle pour la talève sultane
## filtre les données pour la talève sultane
Taleve_sultane <- BirdDataProtocol %>%
  filter(nom_vernaculaire == "Talève sultane, Poule sultane, Porphyrion bleu") %>%
  select(all_of(cols_keep))

## ajoute des colonnes pour le jour julien et son effet quadratique
Taleve_sultane$date_debut <- as.Date(Taleve_sultane$date_debut, format = "%Y-%m-%d")
Taleve_sultane$julian_day <- as.numeric(Taleve_sultane$date_debut)
Taleve_sultane$julian_day2 <- Taleve_sultane$julian_day^2

## ajoute les données hydrologiques au data frame taleve_sultane
Taleve_sultane$annee <- as.integer(format(Taleve_sultane$date_debut, "%Y"))
Taleve_sultane$mois <- as.integer(format(Taleve_sultane$date_debut, "%m"))
Taleve_sultane <- merge(Taleve_sultane, HydrologicDataGrandBagnas, by = c("annee", "mois"), all.x = TRUE)

## Modèle GLM avec la présence de la talève en fonction du temps
glm_taleve_temps <- glm(nombre_min ~ julian_day + I(julian_day^2), family = binomial, data = Taleve_sultane)  
summary(glm_taleve_temps)

## Modèles GLM avec la présence de la talève en fonction de ls conditions hyrdoologiques
glm_taleve_hydro <- glm(nombre_min ~ ProfondeurMoyenne + AssecT_1, family = binomial, data = Taleve_sultane)
summary(glm_taleve_hydro)

## Modèles GLM avec la présence de la talève en fonction du temps et des conditions hydrologiques
glm_taleve_temps_hydro <- glm(nombre_min ~ julian_day + I(julian_day^2) + ProfondeurMoyenne + AssecT_1, family = binomial, data = Taleve_sultane)
summary(glm_taleve_temps_hydro)


library(ggplot2)

ggplot(Taleve_sultane, aes(x = ProfondeurMoyenne, y = nombre_min)) +
  geom_jitter(height = 0.02, width = 0, alpha = 0.5, color = "blue") +
  stat_smooth(method = "glm", method.args = list(family = binomial),
              formula = y ~ x, color = "red", se = TRUE) +
  labs(x = "Profondeur moyenne (m)", y = "Présence (0/1)",
       title = "Effet de la profondeur sur la présence de la Talève sultane") +
  theme_minimal()

library(ggplot2)
library(dplyr)

# Crée une grille de profondeur pour prédiction
depth_seq <- seq(
  min(Taleve_sultane$ProfondeurMoyenne, na.rm = TRUE),
  max(Taleve_sultane$ProfondeurMoyenne, na.rm = TRUE),
  length.out = 100
)

# Crée un dataframe pour prédictions
pred_grid <- data.frame(
  ProfondeurMoyenne = depth_seq,
  julian_day = mean(Taleve_sultane$julian_day, na.rm = TRUE),   # On fixe le temps à la moyenne
  AssecT_1 = "non"                                             # On fixe AssecT_1 à la catégorie de référence
)

# Prédictions de probabilité
pred_grid$prob <- predict(glm_taleve_temps_hydro, newdata = pred_grid, type = "response")

# Heatmap
ggplot(pred_grid, aes(x = ProfondeurMoyenne, y = 1, fill = prob)) +
  geom_tile() +
  scale_fill_gradient(low = "white", high = "steelblue", name = "Probabilité") +
  labs(x = "Profondeur moyenne (m)", y = "", 
       title = "Probabilité prédite de présence de la Talève sultane") +
  theme_minimal() +
  theme(axis.text.y = element_blank(),
        axis.ticks.y = element_blank())

```

Le modèle GLM explorant la présence de la Talève sultane en fonction du temps, de la profondeur et de l’assec de l’année précédente montre que la profondeur moyenne a un effet significatif positif sur la probabilité de présence (Estimate = 2,19, p = 0,035). Les variables temporelles (date julienne et son terme quadratique) ne sont pas significatives (p ≈ 0,09–0,10), indiquant que la présence de l’espèce n’évolue pas de façon marquée au cours de la période 2014–2024. Les effets de l’assec de l’année précédente sont faibles et non significatifs, avec un assec partiel ayant un effet légèrement négatif et un assec total un effet légèrement positif (p ≈ 0,17–0,08).
